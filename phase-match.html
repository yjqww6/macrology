
<html>
 <head>
  <title>Phase 与 identifier的匹配</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style>body {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
  font-family: "Open Sans","Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.6;
  color: rgb(51,51,51);
}
div#whole {
  margin: 10px;
}
h1,h2 {
  border-bottom: solid thin lightgray;
}
ol,ul {
  margin: 0.8em 0;
  padding-left: 30px;
}
div.outer {
  border: solid 1px rgb(243,244,246);
  border-radius: 3px;
  margin: 10px 0 10px 0;
}
pre {
  margin: 0;
  word-wrap: break-word;
  white-space: pre-wrap;
  background: rgb(246,248,250);
  border: solid 1px rgb(239,241,242);
  border-radius: 3px;
  line-height: 1.3;
}
code.racket {
  font-family: 'Fira-Mono', monospace;
}
code.parenthesis {
  color: rgb(132,60,36);
}
code.symbol {
  color: rgb(38, 38, 128);
}
code.hash-colon-keyword {
  color: rgb(132, 60, 36);
}
code.string,code.constant {
  color: rgb(41, 128, 38);
}
code.comment,code.sexp-comment {
  color: rgb(192, 116, 31);
}</style></head>
 <body>
  <div id="whole">
   <h1 id="phase-与-identifier的匹配">Phase 与 identifier的匹配</h1>
   <p>在比较<span><code class="racket symbol">a</code></span>的值是否和某个特定的 <em>identifier</em> <span><code class="racket constant">#'</code><code class="racket symbol">b</code></span>相同时，一般会直接地（或通过<span><code class="racket symbol">syntax-rules</code></span>等间接地）使用<span><code class="racket parenthesis">(</code><code class="racket symbol">free-identifier=?</code><code class="racket"> </code><code class="racket symbol">a</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket symbol">b</code><code class="racket parenthesis">)</code></span>。但也有一些情况不能如此处理。</p>
   <p>在讨论 <em>phase level</em> 与 <em>identifier</em> 的匹配之前，首先要明确几个概念（在The Racket Reference中有更加详细的解释）。</p>
   <ul>
    <li>一个 <em>identifier</em> 在不同的 <em>phase</em> 可以拥有不同的 <em>scope set</em> ，可以解析到相同或不同的 <em>binding</em> ，或者干脆没有 <em>binding</em> 。</li>
    <li>module的 <em>base phase</em> 是其实例化所在的 <em>phase level</em> 。进行<span><code class="racket symbol">require</code></span>的时候，是在相对于 <em>base phase</em> 的环境里引入 <em>binding</em> ：直接的require就是在 <em>base phase</em> ，<span><code class="racket symbol">for-template</code></span>就是 <em>base phase</em> &ndash; 1，以此类推……</li>
    <li><span><code class="racket symbol">free-identifier=?</code></span>比较的是两个 <em>identifier</em> 在给定的 <em>phase level</em> 是否有相同的 <em>binding</em> （或者都没有 <em>binding</em> ），而默认的 <em>phase level</em> 是<span><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code></span>。</li></ul>
   <p>由上可知，<span><code class="racket parenthesis">(</code><code class="racket symbol">free-identifier=?</code><code class="racket"> </code><code class="racket symbol">a</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket symbol">b</code><code class="racket parenthesis">)</code></span>是否正确，一个关键是<span><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code></span>是否就是所期望的 <em>phase level</em> 。</p>
   <h2 id="syntax-local-phase-level的影响">syntax-local-phase-level的影响</h2>
   <p>根据The Racket Reference的解释：</p>
   <pre><code>During the dynamic extent of a syntax transformer application by the expander, the result is the phase level of the form being expanded. Otherwise, the result is 0.</code></pre>
   <p>所以这里就有两种特殊情况了：</p>
   <ul>
    <li>“phase level of the form being expanded” 和目标的 <em>identifier</em> 所在的 <em>phase level</em> 不一致。</li>
    <li>不是在做宏展开。</li></ul>
   <p>注：<span><code class="racket symbol">syntax-local-phase-level</code></span>是有可能得到负数的：</p>
   <div class="outer">
    <pre class="brush: racket"><code class="racket symbol">&gt;</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">module</code><code class="racket"> </code><code class="racket symbol">a</code><code class="racket"> </code><code class="racket symbol">racket</code><code class="racket">
    </code><code class="racket parenthesis">(</code><code class="racket symbol">begin-for-syntax</code><code class="racket">
      </code><code class="racket parenthesis">(</code><code class="racket symbol">displayln</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
</code><code class="racket constant">0</code><code class="racket">
</code><code class="racket constant">0</code><code class="racket">
</code><code class="racket constant">0</code><code class="racket">
</code><code class="racket symbol">&gt;</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">require</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">for-template</code><code class="racket"> </code><code class="racket constant">'</code><code class="racket symbol">a</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
</code><code class="racket constant">-1</code></pre></div>
   <h3 id="phase-level-不一致的情况">Phase Level 不一致的情况</h3>
   <div class="outer">
    <pre class="brush: racket"><code class="racket">#lang racket

</code><code class="racket parenthesis">(</code><code class="racket symbol">module</code><code class="racket"> </code><code class="racket symbol">a</code><code class="racket"> </code><code class="racket symbol">racket</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define-for-syntax</code><code class="racket"> </code><code class="racket symbol">f</code><code class="racket"> </code><code class="racket constant">1</code><code class="racket parenthesis">)</code><code class="racket">
  
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define-syntax</code><code class="racket"> </code><code class="racket symbol">do</code><code class="racket">
    </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-rules</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">f</code><code class="racket parenthesis">)</code><code class="racket">
      </code><code class="racket parenthesis">[</code><code class="racket parenthesis">(</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket symbol">f</code><code class="racket parenthesis">)</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">begin-for-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">displayln</code><code class="racket"> </code><code class="racket constant">1</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">]</code><code class="racket">
      </code><code class="racket parenthesis">[</code><code class="racket parenthesis">(</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket symbol">form</code><code class="racket parenthesis">)</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">begin-for-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">displayln</code><code class="racket"> </code><code class="racket constant">0</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">]</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">

  </code><code class="racket parenthesis">(</code><code class="racket symbol">provide</code><code class="racket"> </code><code class="racket symbol">do</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">for-syntax</code><code class="racket"> </code><code class="racket symbol">f</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">require</code><code class="racket"> </code><code class="racket constant">'</code><code class="racket symbol">a</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket symbol">g</code><code class="racket"> </code><code class="racket constant">0</code><code class="racket parenthesis">)</code><code class="racket">
</code><code class="racket parenthesis">(</code><code class="racket symbol">do</code><code class="racket"> </code><code class="racket symbol">f</code><code class="racket parenthesis">)</code></pre></div>
   <p>这个程序中，a的<span><code class="racket symbol">do</code></span>宏需要将输入与其上面定义在 <em>phase level</em> 1的<span><code class="racket symbol">f</code></span>比较。但是，被展开的代码在0（即<span><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code></span>为<span><code class="racket constant">0</code></span>）。</p>
   <p><span><code class="racket parenthesis">(</code><code class="racket symbol">do</code><code class="racket"> </code><code class="racket symbol">f</code><code class="racket parenthesis">)</code></span>中的<span><code class="racket symbol">f</code></span>在 <em>phase level</em> 0没有 <em>binding</em> ，<span><code class="racket parenthesis">(</code><code class="racket symbol">syntax-rules</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">f</code><code class="racket parenthesis">)</code><code class="racket"> </code><code class="racket symbol">...</code><code class="racket parenthesis">)</code></span>的<span><code class="racket symbol">f</code></span>在 <em>phase level</em> 0也没有 <em>binding</em> 。因此，打印的是<span><code class="racket constant">1</code></span>。</p>
   <p>然而，如果将<span><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket symbol">g</code><code class="racket"> </code><code class="racket constant">0</code><code class="racket parenthesis">)</code></span>中的<span><code class="racket symbol">g</code></span>换成<span><code class="racket symbol">f</code></span>，那么<span><code class="racket parenthesis">(</code><code class="racket symbol">do</code><code class="racket"> </code><code class="racket symbol">f</code><code class="racket parenthesis">)</code></span>中的<span><code class="racket symbol">f</code></span>在 <em>phase level</em> 0解析到这个 <em>binding</em> 。而<span><code class="racket parenthesis">(</code><code class="racket symbol">syntax-rules</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">f</code><code class="racket parenthesis">)</code><code class="racket"> </code><code class="racket symbol">...</code><code class="racket parenthesis">)</code></span>的<span><code class="racket symbol">f</code></span>仍然没有 <em>binding</em> ，结果就是<span><code class="racket constant">0</code></span>了。</p>
   <p>所以，这里的实际问题是<span><code class="racket symbol">syntax-rules</code></span>没有在 <em>phase level</em> 1比较 <em>identifier</em> 。修改方法有：</p>
   <div class="outer">
    <pre class="brush: racket"><code class="racket parenthesis">(</code><code class="racket symbol">define-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">do</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket parenthesis">)</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-case*</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">f</code><code class="racket parenthesis">)</code><code class="racket"> </code><code class="racket symbol">free-transformer-identifier=?</code><code class="racket">
    </code><code class="racket parenthesis">[</code><code class="racket parenthesis">(</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket symbol">f</code><code class="racket parenthesis">)</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket parenthesis">(</code><code class="racket symbol">begin-for-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">displayln</code><code class="racket"> </code><code class="racket constant">1</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">]</code><code class="racket">
    </code><code class="racket parenthesis">[</code><code class="racket parenthesis">(</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket symbol">form</code><code class="racket parenthesis">)</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket parenthesis">(</code><code class="racket symbol">begin-for-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">displayln</code><code class="racket"> </code><code class="racket constant">0</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">]</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code></pre></div>
   <p>或</p>
   <div class="outer">
    <pre class="brush: racket"><code class="racket parenthesis">(</code><code class="racket symbol">define-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">do</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket parenthesis">)</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-case</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket parenthesis">)</code><code class="racket">
    </code><code class="racket parenthesis">[</code><code class="racket parenthesis">(</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket symbol">f-id</code><code class="racket parenthesis">)</code><code class="racket">
     </code><code class="racket parenthesis">(</code><code class="racket symbol">free-transformer-identifier=?</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket symbol">f</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket symbol">f-id</code><code class="racket parenthesis">)</code><code class="racket">
     </code><code class="racket constant">#'</code><code class="racket parenthesis">(</code><code class="racket symbol">begin-for-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">displayln</code><code class="racket"> </code><code class="racket constant">1</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">]</code><code class="racket">
    </code><code class="racket parenthesis">[</code><code class="racket parenthesis">(</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket symbol">form</code><code class="racket parenthesis">)</code><code class="racket">
     </code><code class="racket constant">#'</code><code class="racket parenthesis">(</code><code class="racket symbol">begin-for-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">displayln</code><code class="racket"> </code><code class="racket constant">0</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">]</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code></pre></div>
   <p><span><code class="racket symbol">free-transformer-identifier=?</code></span>在<span><code class="racket parenthesis">(</code><code class="racket symbol">add</code><code class="racket"> </code><code class="racket constant">1</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code></span>进行比较。两边的<span><code class="racket symbol">f</code></span>在 <em>phase level</em> 1有相同的 <em>binding</em> ，不论外面是不是有 <em>phase level</em> 0的<span><code class="racket symbol">f</code></span>干扰，都能不受影响输出<span><code class="racket constant">1</code></span>。</p>
   <h3 id="非宏展开的情况">非宏展开的情况</h3>
   <p>看如下程序：</p>
   <div class="outer">
    <pre class="brush: racket"><code class="racket">#lang racket
</code><code class="racket parenthesis">(</code><code class="racket symbol">module</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket symbol">racket/base</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define-syntax</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-rules</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">provide</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">module</code><code class="racket"> </code><code class="racket symbol">a</code><code class="racket"> </code><code class="racket symbol">racket/base</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">require</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">for-template</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">submod</code><code class="racket"> </code><code class="racket string">".."</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket string">"bad"</code><code class="racket parenthesis">)</code><code class="racket">
  
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">is-foo?</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket parenthesis">)</code><code class="racket">
    </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-case</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code><code class="racket">
      </code><code class="racket parenthesis">[</code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket constant">#t</code><code class="racket parenthesis">]</code><code class="racket">
      </code><code class="racket parenthesis">[</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket constant">#f</code><code class="racket parenthesis">]</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">provide</code><code class="racket"> </code><code class="racket symbol">is-foo?</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">require</code><code class="racket"> </code><code class="racket constant">'</code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">for-syntax</code><code class="racket"> </code><code class="racket constant">'</code><code class="racket symbol">a</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">define-syntax</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">f</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket parenthesis">)</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-case</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket parenthesis">)</code><code class="racket">
    </code><code class="racket parenthesis">[</code><code class="racket parenthesis">(</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket symbol">id</code><code class="racket parenthesis">)</code><code class="racket">
     </code><code class="racket parenthesis">(</code><code class="racket symbol">is-foo?</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket symbol">id</code><code class="racket parenthesis">)</code><code class="racket">
     </code><code class="racket constant">#'</code><code class="racket constant">#t</code><code class="racket parenthesis">]</code><code class="racket">
    </code><code class="racket parenthesis">[</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket constant">#f</code><code class="racket parenthesis">]</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">f</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code></pre></div>
   <p>在module a中，定义了一个辅助函数<span><code class="racket symbol">is-foo?</code></span>，用来判断一个 <em>identifier</em> 是不是解析到module foo的<span><code class="racket symbol">foo</code></span>。</p>
   <p><span><code class="racket symbol">is-foo?</code></span>运行在 <em>phase level 1</em>，因为有<span><code class="racket symbol">for-template</code></span>，a的<span><code class="racket symbol">syntax-case</code></span>的<span><code class="racket symbol">foo</code></span>在 <em>phase level</em> 1 &ndash; 1 = 0 解析到module foo的<span><code class="racket symbol">foo</code></span>。而a定义的<span><code class="racket symbol">foo</code></span>在 <em>phase level</em> 1，因此不会产生干扰。</p>
   <p><span><code class="racket parenthesis">(</code><code class="racket symbol">f</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code></span>的<span><code class="racket symbol">foo</code></span>因为在 <em>phase level</em> 0 require了module foo，所以解析到module foo的<span><code class="racket symbol">foo</code></span>。</p>
   <p>因此二者 <em>binding</em> 相同，结果是<span><code class="racket constant">#t</code></span>。</p>
   <p>然而，如果要在非宏展开的时候使用这两个module，情况就不一样了：</p>
   <div class="outer">
    <pre class="brush: racket"><code class="racket">#lang racket
</code><code class="racket parenthesis">(</code><code class="racket symbol">module</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket symbol">racket/base</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define-syntax</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-rules</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">provide</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">module</code><code class="racket"> </code><code class="racket symbol">a</code><code class="racket"> </code><code class="racket symbol">racket/base</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">require</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">for-template</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">submod</code><code class="racket"> </code><code class="racket string">".."</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket string">"bad"</code><code class="racket parenthesis">)</code><code class="racket">
  
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">is-foo?</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket parenthesis">)</code><code class="racket">
    </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-case</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code><code class="racket">
      </code><code class="racket parenthesis">[</code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket constant">#t</code><code class="racket parenthesis">]</code><code class="racket">
      </code><code class="racket parenthesis">[</code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket constant">#f</code><code class="racket parenthesis">]</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">provide</code><code class="racket"> </code><code class="racket symbol">is-foo?</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">require</code><code class="racket"> </code><code class="racket constant">'</code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket constant">'</code><code class="racket symbol">a</code><code class="racket parenthesis">)</code><code class="racket">

</code><code class="racket parenthesis">(</code><code class="racket symbol">is-foo?</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code></pre></div>
   <p>此时<span><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code></span>仍为0，而module a的<span><code class="racket symbol">foo</code></span>定义在0，module foo的<span><code class="racket symbol">foo</code></span>在”&ndash;1“。这样一来<span><code class="racket symbol">syntax-case</code></span>把<span><code class="racket symbol">stx</code></span>（仍然解析到module foo的<span><code class="racket symbol">foo</code></span>）与module a定义的<span><code class="racket symbol">foo</code></span>相比较，得到<span><code class="racket constant">#f</code></span>。</p>
   <p>就结果而言：</p>
   <ul>
    <li>
     <p>在第一个例子中，module a的 <em>base phase</em> 为1，<span><code class="racket symbol">is-foo?</code></span>比较了<span><code class="racket symbol">stx</code></span>和module foo的<span><code class="racket symbol">foo</code></span>。</p></li>
    <li>
     <p>在第二个例子中，module a的 <em>base phase</em> 为0，<span><code class="racket symbol">is-foo?</code></span>比较了<span><code class="racket symbol">stx</code></span>和module a自己的<span><code class="racket symbol">foo</code></span>。</p></li></ul>
   <p>也就是说，在不改动module a和module foo的情况下，仅仅是使用方式的不同，就使<span><code class="racket symbol">is-foo?</code></span>产生了完全不同的行为。</p>
   <p>解决这个问题的关键是计算module a的 <em>base phase</em> （使用<span><code class="racket symbol">variable-reference-&gt;module-base-phase</code></span>）：</p>
   <div class="outer">
    <pre class="brush: racket"><code class="racket parenthesis">(</code><code class="racket symbol">module</code><code class="racket"> </code><code class="racket symbol">a</code><code class="racket"> </code><code class="racket symbol">racket/base</code><code class="racket">
  </code><code class="racket parenthesis">(</code><code class="racket symbol">require</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">for-template</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">submod</code><code class="racket"> </code><code class="racket string">".."</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket symbol">foo</code><code class="racket"> </code><code class="racket string">"bad"</code><code class="racket parenthesis">)</code><code class="racket">

  </code><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket symbol">base-phase</code><code class="racket">
    </code><code class="racket parenthesis">(</code><code class="racket symbol">variable-reference-&gt;module-base-phase</code><code class="racket">
     </code><code class="racket parenthesis">(</code><code class="racket symbol">#%variable-reference</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  
  </code><code class="racket parenthesis">(</code><code class="racket symbol">define</code><code class="racket"> </code><code class="racket parenthesis">(</code><code class="racket symbol">is-foo?</code><code class="racket"> </code><code class="racket symbol">stx</code><code class="racket parenthesis">)</code><code class="racket">
    </code><code class="racket parenthesis">(</code><code class="racket symbol">free-identifier=?</code><code class="racket">
     </code><code class="racket symbol">stx</code><code class="racket"> </code><code class="racket constant">#'</code><code class="racket symbol">foo</code><code class="racket">
     </code><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code><code class="racket">
     </code><code class="racket parenthesis">(</code><code class="racket symbol">sub1</code><code class="racket"> </code><code class="racket symbol">base-phase</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code><code class="racket">
  
  </code><code class="racket parenthesis">(</code><code class="racket symbol">provide</code><code class="racket"> </code><code class="racket symbol">is-foo?</code><code class="racket parenthesis">)</code><code class="racket parenthesis">)</code></pre></div>
   <p>这样，<span><code class="racket symbol">is-foo?</code></span>总是比较<span><code class="racket symbol">stx</code></span>和module foo的<span><code class="racket symbol">foo</code></span>。</p>
   <p>（另见<a href="https://rmculpepper.github.io/blog/2011/09/syntax-parse-and-literals/">https://rmculpepper.github.io/blog/2011/09/syntax-parse-and-literals/</a>）</p>
   <h2 id="匹配fully-expanded-program">匹配Fully Expanded Program</h2>
   <p><em>Fully Expanded Program</em> （以下简称FPE）中的 <em>identifier</em> 的 <em>phase level</em> 情况也比较微妙。当然，这里的FPE指的是非 <em>expression context</em> 下的FPE——在 <em>expression context</em> 下，FPE并不涉及任何 <em>phase level</em> 的变化，属于平凡的情况。</p>
   <p>非 <em>expression context</em> 的FPE通常有两种来源：</p>
   <ul>
    <li>
     <p>对一个 <em>top-level</em> 的module做完全展开。</p></li>
    <li>
     <p><span><code class="racket symbol">#%module-begin</code></span>对其body做完全展开。</p></li></ul>
   <p>值得注意的是，匹配一个完全展开的 <em>top-level</em> module的情况，是完全可能发生在非宏展开的时候的——各种annotator工作的基本流程就是：expand -&gt; annotate（这里需要进行匹配） -&gt; compile/eval。这个annotate过程正是发生在expander结束工作之后。</p>
   <p>要匹配FPE中的 <em>identifier</em> ，假定表达式是<span><code class="racket parenthesis">(</code><code class="racket symbol">free-identifier=?</code><code class="racket"> </code><code class="racket symbol">id</code><code class="racket"> </code><code class="racket symbol">lit</code><code class="racket"> </code><code class="racket symbol">phase</code><code class="racket"> </code><code class="racket symbol">lit-phase</code><code class="racket parenthesis">)</code></span>。</p>
   <p>这里<span><code class="racket symbol">id</code></span>是输入的 <em>identifier</em> ， <span><code class="racket symbol">lit</code></span>是程序指定的 <em>literal identifier</em> （应当属于<span><code class="racket parenthesis">(</code><code class="racket symbol">kernel-form-identifier-list</code><code class="racket parenthesis">)</code></span>）， 这两个参数没有疑问。而<span><code class="racket symbol">lit-phase</code></span> 需要保证<span><code class="racket symbol">lit</code></span>带有正确的 <em>binding</em> ，取值参照前一节即可。</p>
   <p>所以关键就是<span><code class="racket symbol">phase</code></span>的取值了。</p>
   <h3 id="phase的初值">phase的初值</h3>
   <p>根据上面的两种情况，匹配的起点可能是<span><code class="racket symbol">module</code></span>或者<span><code class="racket symbol">#%plain-module-begin</code></span>。</p>
   <ul>
    <li><span><code class="racket symbol">module</code></span>的情况，取决于FPE的来源：
     <ul>
      <li>如果是通过<span><code class="racket symbol">expand</code></span>/<span><code class="racket symbol">expand-syntax</code></span>展开得到的，那么<span><code class="racket symbol">phase</code></span>的初值应当是<span><code class="racket parenthesis">(</code><code class="racket symbol">namespace-base-phase</code><code class="racket parenthesis">)</code></span>；</li>
      <li>通过<span><code class="racket symbol">local-expand</code></span>（<span><code class="racket symbol">context-v</code></span>为<span><code class="racket constant">'</code><code class="racket symbol">top-level</code></span>）得到。虽然比较罕见，但也是有可能的。<span><code class="racket symbol">phase</code></span>的初值应为<span><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code></span>。并且，非宏展开的情况用不了<span><code class="racket symbol">local-expand</code></span>，<span><code class="racket symbol">lit-phase</code></span>也不用考虑非宏展开的情况。</li></ul></li>
    <li><span><code class="racket symbol">#%plain-module-begin</code></span>肯定是<span><code class="racket symbol">local-expand</code></span>得到的，所以是<span><code class="racket parenthesis">(</code><code class="racket symbol">syntax-local-phase-level</code><code class="racket parenthesis">)</code></span>。但由于module的body总是从 <em>phase level</em> 0开始，所以也可以直接用<span><code class="racket constant">0</code></span>。</li></ul>
   <h3 id="phase的变化">phase的变化</h3>
   <p>除了下面提到的情况外，<span><code class="racket symbol">phase</code></span>都保持不变</p>
   <ul>
    <li>
     <p><span><code class="racket symbol">begin-for-syntax</code></span>和<span><code class="racket symbol">define-syntaxes</code></span>：比较简单，这两个 <em>identifier</em> 本身在<span><code class="racket symbol">phase</code></span>匹配，但对于<span><code class="racket symbol">begin-for-syntax</code></span>的”body“和<span><code class="racket symbol">define-syntaxes</code></span>的”expr“，<span><code class="racket symbol">phase</code></span>需要加1。</p></li>
    <li>
     <p><span><code class="racket symbol">module</code></span>和<span><code class="racket symbol">module*</code></span>：这两个 <em>identifier</em> 本身在<span><code class="racket symbol">phase</code></span>匹配，但对于其”body“，<span><code class="racket symbol">phase</code></span>为<span><code class="racket constant">0</code></span>。</p>
     <ul>
      <li><span><code class="racket parenthesis">(</code><code class="racket symbol">module*</code><code class="racket"> </code><code class="racket symbol">_</code><code class="racket"> </code><code class="racket constant">#f</code><code class="racket"> </code><code class="racket symbol">_</code><code class="racket parenthesis">)</code></span>的情况则是特例，虽然其”body“仍是在 <em>phase level</em> 0展开，但最终得到的FPE经过了shift，所以<span><code class="racket symbol">phase</code></span>无需变动。</li></ul>
     <p>需要注意的是，对于这些submodule的<span><code class="racket symbol">#%plain-module-begin</code></span>，根据module的嵌套的情况，<span><code class="racket symbol">phase</code></span>的变动不固定。但由于<span><code class="racket symbol">#%plain-module-begin</code></span>的位置相对<span><code class="racket symbol">module</code></span>/<span><code class="racket symbol">module*</code></span>固定，所以也并不需要去匹配——直接匹配<span><code class="racket symbol">module</code></span>/<span><code class="racket symbol">module*</code></span>，然后跳过<span><code class="racket symbol">#%plain-module-begin</code></span>处理其”body“即可。</p></li></ul>
   <h3 id="kernel-syntax-casephase">kernel-syntax-case/phase</h3>
   <p>对于匹配FPE，<span><code class="racket symbol">kernel-syntax-case/phase</code></span>是最方便的工具，可以自动处理好 <em>literal identifier</em> 和其 <em>phase level</em> ，用户只需要提供<span><code class="racket symbol">phase</code></span>参数即可。</p>
   <p>如果不需要考虑进入 <em>phase level</em> 大于0的部分，<span><code class="racket symbol">kernel-syntax-case</code></span>也可以用。</p>
   <h3 id="示例">示例</h3>
   <p><span><code class="racket symbol">drcomplete-user-defined</code></span>库里有一段非常简短的代码，可以作为示例，这里就不再另外提供示例代码。</p>
   <p><a href="https://github.com/yjqww6/drcomplete/blob/master/drcomplete-user-defined/private/main.rkt">https://github.com/yjqww6/drcomplete/blob/master/drcomplete-user-defined/private/main.rkt</a></p></div></body></html>